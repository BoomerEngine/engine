package cmake;

import generators.*;
import project.File;
import project.FileType;
import project.Project;
import library.Library;
import library.SystemLibrary;
import library.Config;
import project.ProjectSources;
import utils.GeneratedFile;
import utils.GeneratedFilesCollection;
import utils.KeyValueTable;

import java.util.Comparator;
import java.util.stream.Collectors;
import java.util.stream.Stream;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.nio.file.Files;
import java.nio.file.StandardCopyOption;
import java.io.IOException;

public class CMakeProjectSourcesSetup extends ProjectSourcesSetup {

    public CMakeProjectSourcesSetup(ProjectSources baseSourceProject, SolutionSetup solutionSetup) {
        super(baseSourceProject, solutionSetup);
        this.generatedProjectPath = this.localOutputPath.resolve("CMakeLists.txt");
    }

    @Override
    public void generateProjectLibrariesLinkage(boolean hasStaticInitialization, GeneratedFile f) {
        // no header based linking
    }

    @Override
    public void generateFiles(GeneratedFilesCollection files) {
        generateGenericProjectFiles(files);
        generateProjectFile(files);
    }

    private void generateProjectFile(GeneratedFilesCollection files) {
        GeneratedFile f = files.createFile(generatedProjectPath);

        f.writeln("# Boomer Engine v4");
        f.writeln("# Written by Tomasz Jonarski (Rex Dex)");
        f.writeln("# Build system source code licensed under MIP license");
        f.writeln("# AutoGenerated file. Please DO NOT MODIFY.");
        f.writeln("");
        f.writelnf("project(%s)", mergedName);
        f.writeln("");

        f.writeln("set(CMAKE_CXX_STANDARD 17)");
        f.writeln("set(CMAKE_CXX_STANDARD_REQUIRED ON)");
        f.writeln("set(CMAKE_CXX_EXTENSIONS OFF)");

        f.writelnf("add_definitions(-DPROJECT_NAME=%s)", mergedName);
        f.writeln("string(TOUPPER \"${CMAKE_BUILD_TYPE}\" uppercase_CMAKE_BUILD_TYPE)");
        f.writeln("set(CMAKE_CONFIGURATION_TYPES \"Debug;Checked;Release\")");

        /*System.err.printf("Attributes for project %s:\n", mergedName);
        for (KeyValueTable.Attribute a : attributes.parameters)
            System.err.printf("  [%s] = '%s'\n", a.name, a.value);*/

        if (solutionSetup.solutionType ==  SolutionType.FINAL) {
            f.writeln("add_definitions(-DBUILD_AS_LIBS)");
        } else {
            String exportsMacroName = mergedName.toUpperCase() + "_EXPORTS";
            f.writelnf("add_definitions(-D%s)", exportsMacroName);

            if (!attributes.hasKey("app") && !attributes.hasKey("console"))
                f.writelnf("add_definitions(-DBUILD_DLL)", mergedName);
        }

        for (ProjectSourcesSetup ps : collectSortedSourcesDependencies()) {
            f.writelnf("add_definitions(-DHAS_%s)", ps.mergedName.toUpperCase());
        }

        f.writelnf("set(CMAKE_EXE_LINKER_FLAGS_CHECKED \"${CMAKE_EXE_LINKER_FLAGS_RELEASE}\")");
        f.writelnf("set(CMAKE_SHARED_LINKER_FLAGS_CHECKED \"${CMAKE_SHARED_LINKER_FLAGS_CHECKED}\")");

        f.writeln("set( CMAKE_CXX_FLAGS_DEBUG  \"${CMAKE_CXX_FLAGS_DEBUG} ${CMAKE_CXX_FLAGS} -DBUILD_DEBUG -D_DEBUG -DDEBUG\")");
        f.writeln("set( CMAKE_CXX_FLAGS_CHECKED  \"${CMAKE_CXX_FLAGS_CHECKED} ${CMAKE_CXX_FLAGS} -DBUILD_CHECKED -DNDEBUG\")");
        f.writeln("set( CMAKE_CXX_FLAGS_RELEASE  \"${CMAKE_CXX_FLAGS_RELEASE} ${CMAKE_CXX_FLAGS} -DBUILD_RELEASE -DNDEBUG\")");

        if (solutionSetup.platformType == PlatformType.WINDOWS || solutionSetup.platformType == PlatformType.UWP) {
            f.writelnf("add_definitions(-DUNICODE -D_UNICODE -D_WIN64 -D_WINDOWS -DWIN32_LEAN_AND_MEAN -DNOMINMAX)");
            f.writelnf("add_definitions(-D_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)");
            f.writelnf("add_definitions(-D_SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING)");
            f.writelnf("add_definitions(-D_SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING)");
            f.writelnf("add_definitions(-D_SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING)");

            if (attributes.hasKey("console")) {
                f.writelnf("add_definitions(-DCONSOLE)");
            }
        } else {
            f.writeln("set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -pthread -fno-exceptions\")");

            if (!attributes.hasKey("nosymbols"))
                f.writeln("set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -g\")");

            f.writeln("set( CMAKE_CXX_FLAGS_DEBUG  \"${CMAKE_CXX_FLAGS_DEBUG} ${CMAKE_CXX_FLAGS} -O0 -fstack-protector-all \")");
            f.writeln("set( CMAKE_CXX_FLAGS_CHECKED  \"${CMAKE_CXX_FLAGS_CHECKED} ${CMAKE_CXX_FLAGS} -O2 -fstack-protector-all \")");
            f.writeln("set( CMAKE_CXX_FLAGS_RELEASE  \"${CMAKE_CXX_FLAGS_RELEASE} ${CMAKE_CXX_FLAGS} -O3 -fno-stack-protector\")");
        }

        if (solutionSetup.solutionType == SolutionType.FINAL)
            f.writelnf("add_definitions(-DBUILD_FINAL)");
        else
            f.writelnf("add_definitions(-DBUILD_DEV)");

        f.writeln("# Project include directories");
        for (Path p : extractSourceRoots())
            f.writelnf("include_directories(%s)", solutionSetup.escapePath(p));
        f.writeln("");

        f.writeln("# Project library includes");
        generateProjectLibrariesIncludes(f);
        f.writeln("");

        f.writeln("# Project files");
        for (File pf : this.files)
            generateProjectFileEntry(pf, f);
        f.writeln("");

        // get all source files
        if (requiresRTTI())
        {
            f.writeln("# Generated reflection file");
            f.writelnf("list(APPEND FILE_HEADERS %s)",solutionSetup.escapePath(localGeneratedPath.resolve("reflection.inl")));
            f.writeln("");
        }

        f.writeln("# Project output");
        if (attributes.hasKey("app")) {
            if (solutionSetup.platformType == PlatformType.WINDOWS || solutionSetup.platformType == PlatformType.UWP) {
                f.writelnf("add_executable(%s WIN32 ${FILE_SOURCES} ${FILE_HEADERS})", mergedName);
            } else {
                f.writelnf("add_executable(%s ${FILE_SOURCES} ${FILE_HEADERS})", mergedName);
            }
        } else if (attributes.hasKey("console")) {
            f.writelnf("add_executable(%s ${FILE_SOURCES} ${FILE_HEADERS})", mergedName);
        } else {
            if ((solutionSetup.platformType == PlatformType.WINDOWS || solutionSetup.platformType == PlatformType.UWP) && solutionSetup.solutionType != SolutionType.FINAL) {
                f.writelnf("add_library(%s SHARED ${FILE_SOURCES} ${FILE_HEADERS})", mergedName);
            } else {
                f.writelnf("add_library(%s ${FILE_SOURCES} ${FILE_HEADERS})", mergedName);
            }
        }
        f.writeln("");

        f.writeln("# Project dependencies");
        generateProjectDependencyEntries(f);
        f.writeln("");

        f.writeln("# Stuff to link with the project");
        generateProjectLibrariesLinks(f);
        f.writeln("");

        if (solutionSetup.platformType == PlatformType.LINUX) {
            f.writeln("# Hardcoded system libraries");
            f.writelnf("target_link_libraries(%s dl rt)", mergedName);
        }

        if (solutionSetup.platformType == PlatformType.WINDOWS || solutionSetup.platformType == PlatformType.UWP) {
            f.writeln("# Precompiled header setup");

            for (project.File pf : this.files) {
                if (pf.type != FileType.SOURCE) continue;

                String pch = pf.attributes.value("pch");
                boolean use = true;
                boolean generate = false;
                if (pch.equals("generate")) {
                    generate = true;
                } else if (pch.equals("disable") || pch.equals("disabled")) {
                    use = false;
                }

                if (generate)
                    f.writelnf("set_source_files_properties(%s PROPERTIES COMPILE_FLAGS \"/Ycbuild.h\")", solutionSetup.escapePath(pf.absolutePath));
                else if (use)
                    f.writelnf("set_source_files_properties(%s PROPERTIES COMPILE_FLAGS \"/Yubuild.h\")", solutionSetup.escapePath(pf.absolutePath));
            }

            //f.writelnf("add_precompiled_header(%s build.h FORCEINCLUDE)", name);
            //f.writelnf("set_target_properties(%s PROPERTIES COTIRE_CXX_PREFIX_HEADER_INIT \"build.h\")", name);
            //f.writelnf("cotire(%s)", name);
        }
        f.writeln("");
    }

    private void generateProjectDependencyEntries(GeneratedFile f) {
        for (ProjectSetup dep : collectSortedSourcesDependencies()) {
            if (dep == this) continue;
            f.writelnf("target_link_libraries(%s %s)", mergedName, dep.mergedName);
         }
    }

    private void generateProjectFileEntry(File pf, GeneratedFile f) {
        if (pf.type == FileType.SOURCE) {
            f.writelnf("list(APPEND FILE_SOURCES %s)", solutionSetup.escapePath(pf.absolutePath));
        } else if (pf.type == FileType.HEADER) {
            f.writelnf("list(APPEND FILE_HEADERS %s)", solutionSetup.escapePath(pf.absolutePath));
        }
    }

    private void generateProjectLibrariesIncludes(GeneratedFile f) {
        for (Library lib : collectLibraries("internal")) {
            for (String configName : solutionSetup.allConfigs) {
                for (String platformName : solutionSetup.allPlatforms) {
                    generateProjectLibraryIncludeDirectives(lib, platformName, configName, f);
                }
            }
        }
    }

    private void generateProjectLibrariesLinks(GeneratedFile f) {
        for (Library lib : collectLibraries("internal")) {
            for (String configName : solutionSetup.allConfigs) {
                for (String platformName : solutionSetup.allPlatforms) {
                    generateProjectLibraryLinkDirectives(lib, platformName, configName, f);
                }
            }
        }
    }

    private void generateProjectLibraryIncludeDirectives(Library lib, String platformName, String configName, GeneratedFile f) {
        // get the library setup for given platform and config
        Config.MergedState setup = lib.getSetup(platformName, configName);
        if (!setup.getIncludePaths().isEmpty() || !setup.getLibPaths().isEmpty()) {

            // emit the library include paths into the project
            if (configName.toUpperCase().equals("RELEASE")) {
                for (Path path : setup.getIncludePaths())
                    f.writelnf("include_directories(%s)", solutionSetup.escapePath(path));
            }

            // emit the library link paths into the project
            for (Path path : setup.getLibPaths()) {
                if (Files.exists(path)) {
                    if (configName.toUpperCase().equals("DEBUG"))
                        f.writelnf("link_libraries(debug %s)", solutionSetup.escapePath(path));
                    else if (configName.toUpperCase().equals("RELEASE"))
                        f.writelnf("link_libraries(optimized %s)", solutionSetup.escapePath(path));
                } else {
                    System.err.printf("Library file '%s' referenced by library '%s' manifest does not exist\n", path, lib.name);
                }
            }
        }

        // copy files
        for (Config.DeployFile path : setup.getDeployFiles()) {
            if (Files.exists(path.sourcePath)) {
                Path publishPath = solutionSetup.rootPublishPath.resolve(String.format("%s/bin", configName.toLowerCase()));
                Path targetPath = publishPath.resolve(path.targetPath);
                if (GeneratedFile.ShouldCopyFile(path.sourcePath, targetPath)) {
                    System.out.printf("Copying file \"%s\" to \"%s\"\n", path.sourcePath, targetPath);
                    try {
                        Files.createDirectories(targetPath.getParent());
                        Files.copy(path.sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);
                        Files.setLastModifiedTime(targetPath, Files.getLastModifiedTime(path.sourcePath));
                    }
                    catch (IOException e) {
                        System.err.printf("Failed to copy '%s' referenced by library '%s' into '%s'\n", path.sourcePath, lib.name, targetPath);
                    }
                }
            } else {
                System.err.printf("Deployed file '%s' referenced by library '%s' manifest does not exist\n", path.sourcePath, lib.name);
            }
        }

        // system libaries imports
        if (configName.toUpperCase().equals("RELEASE")) {
            if (!setup.getSystemLibraries().isEmpty()) {
                f.writeln("# Link with system libraries");
                setup.getSystemLibraries().forEach(sl -> generateProjectLibraryImportIncludeDirectives(sl, f));
                f.writeln("");
            }
        }
    }


    private void generateProjectLibraryLinkDirectives(Library lib, String platformName, String configName, GeneratedFile f) {
        // get the library setup for given platform and config
        Config.MergedState setup = lib.getSetup(platformName, configName);


        // system libaries imports
        if (configName.toUpperCase().equals("RELEASE")) {
            if (!setup.getSystemLibraries().isEmpty()) {
                f.writeln("# Link with system libraries");
                setup.getSystemLibraries().forEach(sl -> generateProjectLibraryImportLinkDirectives(sl, f));
                f.writeln("");
            }
        }
    }

    private void generateProjectLibraryImportLinkDirectives(SystemLibrary sl, GeneratedFile f) {
        if (!sl.getLinkDirsNames().isEmpty())
            f.writelnf("link_directories(${%s})", sl.getLinkDirsNames());

        if (!sl.getLibraryFiles().isEmpty())
            f.writelnf("target_link_libraries(%s ${%s})", mergedName, sl.getLibraryFiles());
    }

    private void generateProjectLibraryImportIncludeDirectives(SystemLibrary sl, GeneratedFile f) {
        // emit the library import
        f.writelnf("find_package(%s)", sl.getName());

        if (!sl.getIncludeDirsNames().isEmpty())
            f.writelnf("include_directories(${%s})", sl.getIncludeDirsNames());

        if (!sl.getIncludeFile().isEmpty())
            f.writelnf("include(${%s})", sl.getIncludeFile());

        if (!sl.getDefinitionsName().isEmpty())
            f.writelnf("set( CMAKE_CXX_FLAGS  \"${CMAKE_CXX_FLAGS} ${%s}\")",   sl.getDefinitionsName());

        if (!sl.getFlags().isEmpty())
            f.writelnf("set( CMAKE_CXX_FLAGS  \"${CMAKE_CXX_FLAGS} %s\")",   sl.getFlags());
    }
}

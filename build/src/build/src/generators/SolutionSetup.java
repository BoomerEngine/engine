package generators;

import library.LibraryManager;
import project.FileType;
import project.Project;
import project.ProjectSources;
import project.Solution;
import project.dependencies.Dependency;
import project.dependencies.DependencyType;
import utils.GeneratedFile;
import utils.GeneratedFilesCollection;
import utils.KeyValueTable;

import java.io.IOException;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.security.InvalidParameterException;
import java.util.*;
import java.util.stream.Collectors;

public abstract class SolutionSetup {

  public Path mainProjectPath;
  public LibraryManager libs;

  public PlatformType platformType;
  public SolutionType solutionType;

  public Path rootPublishPath;

  public Path rootOutputPath;
  public Path rootOutputTempPath;
  public Path rootOutputProjectsPath;

  public Path rootGeneratedPath;
  public Path rootGeneratedSharedPath;
  public Path rootGeneratedGluedPath;

  public Path buildToolsPath;
  public Path buildScriptsPath;

  public Path rttiManifestPath;

  public List<String> allPlatforms = new ArrayList<>();
  public List<String> allConfigs = new ArrayList<>();

  public List<ProjectSetup> projects = new ArrayList<>();

  //---

  public SolutionSetup(Solution baseSolution, KeyValueTable params) throws IOException {

    // copy base stuff
    this.libs = baseSolution.libs;
    this.mainProjectPath = baseSolution.mainProjectPath;
    this.platformType = baseSolution.platformType;
    this.solutionType = baseSolution.solutionType;

    // read the commandline params
    this.rootPublishPath = baseSolution.buildPublishPath.normalize();
    this.rootOutputPath = baseSolution.buildOutputPath;
    this.rootOutputTempPath = baseSolution.buildOutputPath.resolve("output/").normalize();
    this.rootOutputProjectsPath = baseSolution.buildOutputPath.resolve("projects/").normalize();
    this.rootGeneratedPath = baseSolution.buildOutputPath.resolve("generated/").normalize();
    this.rootGeneratedSharedPath = baseSolution.buildOutputPath.resolve("generated/_shared/").normalize();
    this.rootGeneratedGluedPath = baseSolution.buildOutputPath.resolve("generated/_glued/").normalize();
    this.rttiManifestPath = this.rootOutputPath.resolve("rtti.xml");

    //--

    // dump
    System.out.printf("Root output temp path: '%s'\n", rootOutputTempPath.toString());
    System.out.printf("Root output projects path: '%s'\n", rootOutputProjectsPath.toString());
    System.out.printf("Root generated path: '%s'\n", rootGeneratedPath.toString());
    System.out.printf("Root generated shared path: '%s'\n", rootGeneratedSharedPath.toString());
    System.out.printf("RTTI manifest will be written to '%s'\n", rttiManifestPath.toString());
  }

  //---

  public String escapePath(String path) {
    StringBuilder sb = new StringBuilder();
    sb.append("\"");
    if (platformType == PlatformType.WINDOWS || platformType == PlatformType.UWP) {
      String temp = path.replace('\\', '/');
      for (int i=0; i<temp.length(); i++)
        switch (temp.charAt(i)) {
          //case '\\': sb.append("\\\\"); break;
          default: sb.append(temp.charAt(i));
        }
    } else {
      String temp = path.replace('\\', '/');
      sb.append(temp);
    }
    sb.append("\"");
    return sb.toString();
  }

  protected void generateRTIIManifest(GeneratedFilesCollection files) {
    // get all projects that we want to have RTTI for
    List<ProjectSourcesSetup> projectsWithRTTI = new ArrayList<>();
    for (ProjectSetup dep : projects) {
      if (dep instanceof ProjectSourcesSetup) {
        ProjectSourcesSetup sourcesDep = (ProjectSourcesSetup) dep;
        if (sourcesDep != null && sourcesDep.requiresRTTI()) {
          projectsWithRTTI.add(sourcesDep);
        }
      }
    }

    // sort the projects so we have some kind of determinism in generating the rtti manifest
    projectsWithRTTI.sort((a,b) -> a.mergedName.compareTo(b.mergedName));

    // create the rtti manifest file
    GeneratedFile f = files.createFile(rttiManifestPath);

    // print content to the manifest
    f.writeln("<?xml version=\"1.0\" encoding=\"UTF-8\"?>");
    f.writeln("<!-- autogenerated list of projects for RTTI generator -->");
    f.writeln("<rtti>");

    if (solutionType.includeTests)
      f.writeln("  <includeTests/>");

    for (ProjectSourcesSetup p : projectsWithRTTI) {
      f.writeln("  <project>");
      f.writelnf("    <name>%s</name>", p.mergedName);
      f.writelnf("    <output>%s</output>", p.localGeneratedPath.resolve("reflection.inl"));
      f.writelnf("    <src>%s</src>", p.sourcesAbsolutePath.resolve("src"));
      f.writeln("  </project>");
    }

    f.writeln("</rtti>");
  }

  public void generateGluedBigHeader(GeneratedFilesCollection files) {
    Path bigHeaderPath = rootGeneratedGluedPath.resolve("BoomerEngine.h");
    GeneratedFile f = files.createFile(bigHeaderPath);
    f.writelnf("// Boomer Engine \"Big Header\"");
    f.writeln("// This header is licensed under MIT license");
    f.writelnf("\n");

    f.writelnf("// All public headers");
    List<ProjectSourcesSetup> projectToEmit = new ArrayList<ProjectSourcesSetup>();

    for (ProjectSetup p : projects) {
      if (p instanceof ProjectSourcesSetup) {
        ProjectSourcesSetup ps = (ProjectSourcesSetup) p;
        if (p.attributes.hasKey("app"))
          continue;

        boolean hasPublicHeader = false;
        for (project.File pf : ps.files) {
          if (pf.shortName.equals("public.h")) {
            hasPublicHeader = true;
            break;
          }
        }

        if (hasPublicHeader)
          projectToEmit.add(ps);
      }
    }

    int numHeadersWritten = 0;
    for (ProjectSourcesSetup ps : projectToEmit) {
      f.writelnf("");
      f.writelnf("#ifdef HAS_%s", ps.mergedName.toUpperCase());
      f.writelnf("// Project '%s'", ps.mergedName);

      for (project.File pf : ps.files)
        if (pf.shortName.equals("public.h"))
          f.writelnf("#include \"%s\"", pf.absolutePath);

      for (project.File pf : ps.files) {
        if (!pf.shortName.equals("public.h") && !pf.shortName.startsWith("gtest-")) {
          if (pf.type == FileType.HEADER && pf.relativePath.startsWith("include")) {
            f.writelnf("#include \"%s\"", pf.absolutePath);
            numHeadersWritten += 1;
          }
        }
      }

      f.writelnf("#endif");
    }

    System.out.printf("Written %d includes to big header '%s'\n", numHeadersWritten, bigHeaderPath);
  }

  public String escapePath(Path path) {
    return escapePath(path.toAbsolutePath().toString());
  }

  // generate all files for this solution
  public abstract void generateFiles(GeneratedFilesCollection files);

}

#include "common.h"
#include "project.h"
#include "generated.h"
#include "generatorCMAKE.h"

SolutionGeneratorCMAKE::SolutionGeneratorCMAKE(const Configuration& config, CodeGenerator& gen)
    : m_config(config)
    , m_gen(gen)
{
    m_cmakeScriptsPath = config.builderEnvPath / "cmake";
    m_buildWithLibs = (config.libs == LibraryType::Static);
}

void SolutionGeneratorCMAKE::printSolutionDeclarations(std::stringstream& f, const CodeGenerator::GeneratedGroup* g)
{

}

void SolutionGeneratorCMAKE::printSolutionParentLinks(std::stringstream& f, const CodeGenerator::GeneratedGroup* g)
{

}

static const char* NameCMakeConfiguration(ConfigurationType config)
{    
    switch (config)
    {
        case ConfigurationType::Checked: return "Checked";
        case ConfigurationType::Release: return "Release";
        case ConfigurationType::Debug: return "Debug";
        case ConfigurationType::Final: return "Final";
    }

    return "Release";
}

static std::string EscapePath(fs::path path)
{
    path.make_preferred();

    std::stringstream ss;
    ss << "\"";
    ss << MakeGenericPath(path.u8string());
    ss << "\"";

    return ss.str();
}

bool SolutionGeneratorCMAKE::generateSolution()
{
    auto* file = m_gen.createFile(m_config.solutionPath / "CMakeLists.txt");
    auto& f = file->content;

    writeln(f, "# Boomer Engine v4");
    writeln(f, "# Written by Tomasz Jonarski (Rex Dex)");
    writeln(f, "# AutoGenerated file. Please DO NOT MODIFY.");
    writeln(f, "# Build system source code licensed under MIP license");
    writeln(f, "");

    writeln(f, "project(BoomerEngine)");
    writeln(f, "");
    writeln(f, "cmake_minimum_required(VERSION 2.8.10)");
    writeln(f, "");

    //writeln(f, "#SET(CMAKE_C_COMPILER /usr/bin/gcc)");
    //writeln(f, "#SET(CMAKE_CXX_COMPILER /usr/bin/gcc)");
    //writeln(f, "#set(CMAKE_DISABLE_IN_SOURCE_BUILD ON)");
    //writeln(f, "#set(CMAKE_DISABLE_SOURCE_CHANGES  ON)");

    writeln(f, "set(CMAKE_VERBOSE_MAKEFILE ON)");
    writeln(f, "set(CMAKE_COLOR_MAKEFILE ON)");
    writelnf(f, "set(CMAKE_CONFIGURATION_TYPES \"%s\")", NameCMakeConfiguration(m_config.configuration));
    writeln(f, "set(OpenGL_GL_PREFERENCE \"GLVND\")");
    writelnf(f, "set(CMAKE_MODULE_PATH %s)", EscapePath(m_cmakeScriptsPath).c_str());
    writelnf(f, "set(CMAKE_ARCHIVE_OUTPUT_DIRECTORY %s)", EscapePath(m_config.solutionPath / "lib").c_str());
    writelnf(f, "set(CMAKE_LIBRARY_OUTPUT_DIRECTORY %s)", EscapePath(m_config.solutionPath / "lib").c_str());
    writelnf(f, "set(CMAKE_RUNTIME_OUTPUT_DIRECTORY %s)", EscapePath(m_config.deployPath).c_str());

    //if (solution.platformType == PlatformType.WINDOWS)
    writeln(f, "set_property(GLOBAL PROPERTY USE_FOLDERS ON)");

    writeln(f, "");

    writeln(f, "#include(cotire)");
    writeln(f, "#include(PrecompiledHeader)");
    writeln(f, "include(OptimizeForArchitecture)"); // Praise OpenSource!
    writeln(f, "");

    for (const auto* p : m_gen.projects)
        if (p->originalProject->type == ProjectType::LocalLibrary || p->originalProject->type == ProjectType::LocalApplication)
            writelnf(f, "add_subdirectory(%s)", EscapePath(p->generatedPath).c_str());

    return true;
}

bool SolutionGeneratorCMAKE::generateProjects()
{
    bool valid = true;

    for (const auto* p : m_gen.projects)
    {
        if (p->originalProject->type == ProjectType::LocalLibrary || p->originalProject->type == ProjectType::LocalApplication)
        {
            const fs::path projectPath = p->generatedPath / "CMakeLists.txt";

            auto* file = m_gen.createFile(projectPath);
            valid &= generateProjectFile(p, file->content);
        }
    }

    return valid;
}

void SolutionGeneratorCMAKE::extractSourceRoots(const CodeGenerator::GeneratedProject* project, std::vector<fs::path>& outPaths) const
{
    for (const auto& sourceRoot : m_gen.sourceRoots)
        outPaths.push_back(sourceRoot);

    outPaths.push_back(project->originalProject->rootPath / "src");
    outPaths.push_back(project->originalProject->rootPath / "include");

    outPaths.push_back(m_config.solutionPath / "generated/_shared");
    outPaths.push_back(project->generatedPath);
}

bool SolutionGeneratorCMAKE::shouldStaticLinkProject(const CodeGenerator::GeneratedProject* project) const
{
    if (project->originalProject->flagForceSharedLibrary)
        return false;
    else if (project->originalProject->flagForceStaticLibrary)
        return true;
    else
        return m_buildWithLibs;
}

bool SolutionGeneratorCMAKE::generateProjectFile(const CodeGenerator::GeneratedProject* p, std::stringstream& f) const
{
    const auto windowsPlatform = (m_config.platform == PlatformType::Windows || m_config.platform == PlatformType::UWP);

    writeln(f, "# Boomer Engine v4");
    writeln(f, "# Written by Tomasz Jonarski (Rex Dex)");
    writeln(f, "# Build system source code licensed under MIT license");
    writeln(f, "# AutoGenerated file. Please DO NOT MODIFY.");
    writeln(f, "");
    writelnf(f, "project(%s)", p->mergedName.c_str());
    writeln(f, "");

    writeln(f, "set(CMAKE_CXX_STANDARD 17)");
    writeln(f, "set(CMAKE_CXX_STANDARD_REQUIRED ON)");
    writeln(f, "set(CMAKE_CXX_EXTENSIONS OFF)");

    writelnf(f, "add_definitions(-DPROJECT_NAME=%s)", p->mergedName.c_str());
    writeln(f, "string(TOUPPER \"${CMAKE_BUILD_TYPE}\" uppercase_CMAKE_BUILD_TYPE)");
    writelnf(f, "set(CMAKE_CONFIGURATION_TYPES \"%s\")", NameCMakeConfiguration(m_config.configuration));

    const bool staticLink = shouldStaticLinkProject(p);
    if (staticLink)
    {
        writeln(f, "add_definitions(-DBUILD_AS_LIBS)");
    }
    else
    {
        std::string exportsMacroName = ToUpper(p->mergedName) + "_EXPORTS";
        writelnf(f, "add_definitions(-D%s)", exportsMacroName.c_str());

        if (p->originalProject->type == ProjectType::LocalLibrary)
            writeln(f, "add_definitions(-DBUILD_DLL)");
    }

    for (const auto* dep : p->allDependencies)
    {
        if (dep->originalProject->type == ProjectType::LocalLibrary)
            writelnf(f, "add_definitions(-DHAS_%s)", ToUpper(dep->mergedName).c_str());
    }

    writelnf(f, "set(CMAKE_EXE_LINKER_FLAGS_CHECKED \"${CMAKE_EXE_LINKER_FLAGS_RELEASE}\")");
    writelnf(f, "set(CMAKE_SHARED_LINKER_FLAGS_CHECKED \"${CMAKE_SHARED_LINKER_FLAGS_CHECKED}\")");

    if (m_config.configuration == ConfigurationType::Debug)
        writeln(f, "set( CMAKE_CXX_FLAGS  \"${CMAKE_CXX_FLAGS} /MP -DBUILD_DEBUG -D_DEBUG -DDEBUG\")");
    else if (m_config.configuration == ConfigurationType::Checked)
        writeln(f, "set( CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} /MP -DBUILD_CHECKED -DNDEBUG\")");
    else if (m_config.configuration == ConfigurationType::Release)
        writeln(f, "set( CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} /MP -DBUILD_RELEASE -DNDEBUG\")");
    else if (m_config.configuration == ConfigurationType::Final)
        writeln(f, "set( CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} /MP -DBUILD_RELEASE -DBUILD_FINAL -DNDEBUG\")");

    if (windowsPlatform)
    {
        writeln(f, "add_definitions(-DUNICODE -D_UNICODE -D_WIN64 -D_WINDOWS -DWIN32_LEAN_AND_MEAN -DNOMINMAX)");
        writeln(f, "add_definitions(-D_SILENCE_ALL_CXX17_DEPRECATION_WARNINGS)");
        writeln(f, "add_definitions(-D_SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING)");
        writeln(f, "add_definitions(-D_SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING)");
        writeln(f, "add_definitions(-D_SILENCE_CXX17_CODECVT_HEADER_DEPRECATION_WARNING)");

        if (p->originalProject->flagConsole)
            writeln(f, "add_definitions(-DCONSOLE)");
    }
    else
    {
        writeln(f, "set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -pthread -fno-exceptions\")");

        writeln(f, "set(CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -g\")");

        if (m_config.configuration == ConfigurationType::Debug)
            writeln(f, "set( CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -O0 -fstack-protector-all\")");
        else if (m_config.configuration == ConfigurationType::Checked)
            writeln(f, "set( CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -O2 -fstack-protector-all\")");
        else
            writeln(f, "set( CMAKE_CXX_FLAGS \"${CMAKE_CXX_FLAGS} -O3 -fno-stack-protector\")");
    }

    /*if (solutionSetup.solutionType == SolutionType.FINAL)
        writelnf(f, "add_definitions(-DBUILD_FINAL)");
    else
        writelnf(f, "add_definitions(-DBUILD_DEV)");*/

    std::vector<fs::path> paths;
    extractSourceRoots(p, paths);

    writeln(f, "# Project include directories");
    for (const auto& path : paths)
        writelnf(f, "include_directories(%s)", EscapePath(path).c_str());
    writeln(f, "");

    writeln(f, "# Project library includes");
    for (const auto* lib : p->originalProject->resolvedDependencies)
    {
        if (lib->type == ProjectType::ExternalLibrary)
        {
            for (const auto& path : lib->libraryInlcudePaths)
                writelnf(f, "include_directories(%s)", EscapePath(path).c_str());

            for (const auto& path : lib->libraryLinkFile)
                writelnf(f, "link_libraries(%s)", EscapePath(path).c_str());
        }
    }
    writeln(f, "");

    writeln(f, "# Project files");
    for (const auto* pf : p->files)
    {
        if (pf->useInCurrentBuild)
        {
            if (fs::is_regular_file(pf->absolutePath))
            {
                if (pf->type == ProjectFileType::CppSource)
                    writelnf(f, "list(APPEND FILE_SOURCES %s)", EscapePath(pf->absolutePath).c_str());
                else if (pf->type == ProjectFileType::CppHeader)
                    writelnf(f, "list(APPEND FILE_HEADERS %s)", EscapePath(pf->absolutePath).c_str());
            }
        }
    }
    writeln(f, "");

    /*// get all source files
    if (requiresRTTI())
    {
        writeln(f, "# Generated reflection file");
        writelnf(f, "list(APPEND FILE_HEADERS %s)", solutionSetup.escapePath(localGeneratedPath.resolve("reflection.inl")));
        writeln(f, "");
    }*/

    writeln(f, "# Project output");
    if (p->originalProject->type == ProjectType::LocalApplication)
    {
        if (p->originalProject->flagConsole || !windowsPlatform)
            writelnf(f, "add_executable(%s ${FILE_SOURCES} ${FILE_HEADERS})", p->mergedName.c_str());
        else
            writelnf(f, "add_executable(%s WIN32 ${FILE_SOURCES} ${FILE_HEADERS})", p->mergedName.c_str());
    }
    else
    {
        if (staticLink)
            writelnf(f, "add_library(%s ${FILE_SOURCES} ${FILE_HEADERS})", p->mergedName.c_str());
        else
            writelnf(f, "add_library(%s SHARED ${FILE_SOURCES} ${FILE_HEADERS})", p->mergedName.c_str());
    }

    writeln(f, "");

    writeln(f, "# Project dependencies");
    if (p->originalProject->type == ProjectType::LocalApplication)
    {
        for (const auto* dep : p->allDependencies)
            writelnf(f, "target_link_libraries(%s %s)", p->mergedName.c_str(), dep->mergedName.c_str());
    }
    else if (!staticLink)
    {
        for (const auto* dep : p->directDependencies)
            writelnf(f, "target_link_libraries(%s %s)", p->mergedName.c_str(), dep->mergedName.c_str());
    }
    writeln(f, "");

    if (m_config.platform == PlatformType::Linux)
    {
        writeln(f, "# Hardcoded system libraries");
        writelnf(f, "target_link_libraries(%s dl rt)", p->mergedName.c_str());
    }
    else if (m_config.platform == PlatformType::Windows || m_config.platform == PlatformType::UWP)
    {
        writeln(f, "# Precompiled header setup");

        for (const auto* pf : p->files)
        {
            if (pf->type == ProjectFileType::CppSource)
            {
                if (pf->name == "build.cpp")
                    writelnf(f, "set_source_files_properties(%s PROPERTIES COMPILE_FLAGS \"/Ycbuild.h\")", EscapePath(pf->absolutePath).c_str());
                else if (pf->originalFile && pf->originalFile->flagUsePch)
                    writelnf(f, "set_source_files_properties(%s PROPERTIES COMPILE_FLAGS \"/Yubuild.h\")", EscapePath(pf->absolutePath).c_str());
            }
        }

        //writelnf(f, "add_precompiled_header(%s build.h FORCEINCLUDE)", name);
        //writelnf(f, "set_target_properties(%s PROPERTIES COTIRE_CXX_PREFIX_HEADER_INIT \"build.h\")", name);
        //writelnf(f, "cotire(%s)", name);
    }

    writeln(f, "");

    return true;
}

#if 0
private void generateProjectFile(GeneratedFilesCollection files) {

}

private void generateProjectDependencyEntries(GeneratedFile f) {
    for (ProjectSetup dep : collectSortedSourcesDependencies()) {
        if (dep == this) continue;
        writelnf(f, "target_link_libraries(%s %s)", mergedName, dep.mergedName);
    }
}

private void generateProjectFileEntry(File pf, GeneratedFile f) {
    
}

private void generateProjectLibrariesIncludes(GeneratedFile f) {
    for (Library lib : collectLibraries("internal")) {
        for (String configName : solutionSetup.allConfigs) {
            for (String platformName : solutionSetup.allPlatforms) {
                generateProjectLibraryIncludeDirectives(lib, platformName, configName, f);
            }
        }
    }
}

private void generateProjectLibrariesLinks(GeneratedFile f) {
    for (Library lib : collectLibraries("internal")) {
        for (String configName : solutionSetup.allConfigs) {
            for (String platformName : solutionSetup.allPlatforms) {
                generateProjectLibraryLinkDirectives(lib, platformName, configName, f);
            }
        }
    }
}

private void generateProjectLibraryIncludeDirectives(Library lib, String platformName, String configName, GeneratedFile f) {
    // get the library setup for given platform and config
    Config.MergedState setup = lib.getSetup(platformName, configName);
    if (!setup.getIncludePaths().isEmpty() || !setup.getLibPaths().isEmpty()) {

        // emit the library include paths into the project
        if (configName.toUpperCase().equals("RELEASE")) {
            for (Path path : setup.getIncludePaths())
                writelnf(f, "include_directories(%s)", solutionSetup.escapePath(path));
        }

        // emit the library link paths into the project
        for (Path path : setup.getLibPaths()) {
            if (Files.exists(path)) {
                if (configName.toUpperCase().equals("DEBUG"))
                    writelnf(f, "link_libraries(debug %s)", solutionSetup.escapePath(path));
                else if (configName.toUpperCase().equals("RELEASE"))
                    writelnf(f, "link_libraries(optimized %s)", solutionSetup.escapePath(path));
            }
            else {
                System.err.printf("Library file '%s' referenced by library '%s' manifest does not exist\n", path, lib.name);
            }
        }
    }

    // copy files
    for (Config.DeployFile path : setup.getDeployFiles()) {
        if (Files.exists(path.sourcePath)) {
            Path publishPath = solutionSetup.rootPublishPath.resolve(String.format("%s/bin", configName.toLowerCase()));
            Path targetPath = publishPath.resolve(path.targetPath);
            if (GeneratedFile.ShouldCopyFile(path.sourcePath, targetPath)) {
                System.out.printf("Copying file \"%s\" to \"%s\"\n", path.sourcePath, targetPath);
                try {
                    Files.createDirectories(targetPath.getParent());
                    Files.copy(path.sourcePath, targetPath, StandardCopyOption.REPLACE_EXISTING);
                    Files.setLastModifiedTime(targetPath, Files.getLastModifiedTime(path.sourcePath));
                }
                catch (IOException e) {
                    System.err.printf("Failed to copy '%s' referenced by library '%s' into '%s'\n", path.sourcePath, lib.name, targetPath);
                }
            }
        }
        else {
            System.err.printf("Deployed file '%s' referenced by library '%s' manifest does not exist\n", path.sourcePath, lib.name);
        }
    }

    // system libaries imports
    if (configName.toUpperCase().equals("RELEASE")) {
        if (!setup.getSystemLibraries().isEmpty()) {
            writeln(f, "# Link with system libraries");
            setup.getSystemLibraries().forEach(sl->generateProjectLibraryImportIncludeDirectives(sl, f));
            writeln(f, "");
        }
    }
}


private void generateProjectLibraryLinkDirectives(Library lib, String platformName, String configName, GeneratedFile f) {
    // get the library setup for given platform and config
    Config.MergedState setup = lib.getSetup(platformName, configName);


    // system libaries imports
    if (configName.toUpperCase().equals("RELEASE")) {
        if (!setup.getSystemLibraries().isEmpty()) {
            writeln(f, "# Link with system libraries");
            setup.getSystemLibraries().forEach(sl->generateProjectLibraryImportLinkDirectives(sl, f));
            writeln(f, "");
        }
    }
}

private void generateProjectLibraryImportLinkDirectives(SystemLibrary sl, GeneratedFile f) {
    if (!sl.getLinkDirsNames().isEmpty())
        writelnf(f, "link_directories(${%s})", sl.getLinkDirsNames());

    if (!sl.getLibraryFiles().isEmpty())
        writelnf(f, "target_link_libraries(%s ${%s})", mergedName, sl.getLibraryFiles());
}

private void generateProjectLibraryImportIncludeDirectives(SystemLibrary sl, GeneratedFile f) {
    // emit the library import
    writelnf(f, "find_package(%s)", sl.getName());

    if (!sl.getIncludeDirsNames().isEmpty())
        writelnf(f, "include_directories(${%s})", sl.getIncludeDirsNames());

    if (!sl.getIncludeFile().isEmpty())
        writelnf(f, "include(${%s})", sl.getIncludeFile());

    if (!sl.getDefinitionsName().isEmpty())
        writelnf(f, "set( CMAKE_CXX_FLAGS  \"${CMAKE_CXX_FLAGS} ${%s}\")", sl.getDefinitionsName());

    if (!sl.getFlags().isEmpty())
        writelnf(f, "set( CMAKE_CXX_FLAGS  \"${CMAKE_CXX_FLAGS} %s\")", sl.getFlags());
}
}
#endif